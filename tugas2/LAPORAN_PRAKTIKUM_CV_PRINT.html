<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laporan Tugas Computer Vision - Operasi Geometrik</title>
    
    <!-- Print optimization meta tags -->
    <meta name="format-detection" content="telephone=no">
    <meta name="robots" content="noprint">
    <style>
        /* Print-optimized CSS */
        @page {
            size: legal;
            margin: 2.5cm 2cm 2cm 2cm;
            /* Remove browser headers and footers */
            @top-left { content: ""; }
            @top-center { content: ""; }
            @top-right { content: ""; }
            @bottom-left { content: ""; }
            @bottom-center { content: ""; }
            @bottom-right { content: ""; }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.6;
            color: #000;
            background: white;
            max-width: 216mm; /* Legal width */
            margin: 0 auto;
            padding: 20px;
        }

        /* Headers */
        h1 {
            font-size: 16pt;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10pt;
            text-transform: uppercase;
            page-break-after: avoid;
        }

        h2 {
            font-size: 14pt;
            font-weight: bold;
            text-align: center;
            margin: 15pt 0 10pt 0;
            text-transform: uppercase;
            page-break-after: avoid;
        }

        h3 {
            font-size: 13pt;
            font-weight: bold;
            margin: 12pt 0 8pt 0;
            page-break-after: avoid;
        }

        h4 {
            font-size: 12pt;
            font-weight: bold;
            margin: 10pt 0 6pt 0;
            page-break-after: avoid;
        }

        h5 {
            font-size: 12pt;
            font-weight: bold;
            margin: 8pt 0 4pt 0;
            page-break-after: avoid;
        }

        /* Paragraphs */
        p {
            margin-bottom: 8pt;
            text-align: justify;
            text-indent: 1cm;
        }

        .no-indent {
            text-indent: 0;
        }

        /* Lists */
        ul, ol {
            margin: 8pt 0 8pt 2cm;
        }

        li {
            margin-bottom: 4pt;
            text-align: justify;
        }

        /* Code blocks */
        pre {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10pt;
            margin: 8pt 0;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
            line-height: 1.4;
            overflow-x: auto;
            page-break-inside: avoid;
        }

        code {
            font-family: 'Courier New', monospace;
            font-size: 10pt;
            background: #f5f5f5;
            padding: 2pt 4pt;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10pt 0;
            page-break-inside: avoid;
        }

        th, td {
            border: 1px solid #000;
            padding: 6pt;
            text-align: left;
            vertical-align: top;
        }

        th {
            background: #f0f0f0;
            font-weight: bold;
        }

        /* Images */
        .figure {
            text-align: center;
            margin: 15pt 0;
            page-break-inside: avoid;
        }

        .figure img {
            max-width: 100%;
            max-height: 12cm;
            border: 1px solid #ddd;
        }

        .figure-caption {
            font-style: italic;
            margin-top: 8pt;
            font-size: 11pt;
        }

        /* Header info section - Cover page */
        .header-info {
            text-align: center;
            margin: 40pt auto;
            page-break-after: avoid;
            max-width: 70%;
            padding: 40pt 30pt;
        }

        .header-info p {
            text-indent: 0;
            margin: 8pt 0;
            font-size: 12pt;
        }

        .header-info .course-info {
            font-size: 13pt;
            font-weight: bold;
            margin: 20pt 0;
            padding-bottom: 15pt;
        }

        .header-info .student-info {
            margin-top: 25pt;
            font-size: 12pt;
            line-height: 1.8;
        }

        /* Cover page layout */
        .cover-page {
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 50pt 20pt;
        }

        .cover-page h1 {
            margin-bottom: 20pt;
            font-size: 18pt;
        }

        .cover-page h2 {
            margin-bottom: 40pt;
            font-size: 16pt;
        }

        /* Print adjustments for cover */
        @media print {
            .cover-page {
                height: 90vh;
                page-break-after: always;
            }
        }

        /* Horizontal rules */
        hr {
            border: none;
            border-top: 2px solid #000;
            margin: 15pt 0;
            page-break-after: avoid;
        }

        /* Page breaks */
        .page-break {
            page-break-before: always;
        }

        .avoid-break {
            page-break-inside: avoid;
        }

        /* Question/Answer blocks */
        .question-block {
            margin: 12pt 0;
            page-break-inside: avoid;
        }

        .question {
            font-weight: bold;
            margin-bottom: 6pt;
        }

        .answer {
            margin-left: 1cm;
            text-align: justify;
        }

        /* Emphasis */
        .bold {
            font-weight: bold;
        }

        .italic {
            font-style: italic;
        }

        /* Print-specific */
        @media print {
            body {
                margin: 0;
                padding: 0;
                max-width: none;
            }

            .no-print {
                display: none;
            }

            a {
                color: black;
                text-decoration: none;
            }

            /* Remove browser default headers and footers */
            @page {
                margin-top: 2.5cm;
                margin-bottom: 2cm;
                margin-left: 2cm;
                margin-right: 2cm;
                
                /* Suppress browser headers/footers */
                @top-left-corner { content: ""; }
                @top-left { content: ""; }
                @top-center { content: ""; }
                @top-right { content: ""; }
                @top-right-corner { content: ""; }
                @bottom-left-corner { content: ""; }
                @bottom-left { content: ""; }
                @bottom-center { content: ""; }
                @bottom-right { content: ""; }
                @bottom-right-corner { content: ""; }
            }

            /* Ensure proper page breaks */
            h1, h2, h3 {
                page-break-after: avoid;
            }

            .figure, .question-block, pre, table {
                page-break-inside: avoid;
            }
        }

        /* Table of contents */
        .toc {
            margin: 20pt 0;
        }

        .toc-item {
            text-indent: 0;
            margin: 4pt 0;
        }

        .toc-level-1 { margin-left: 0; }
        .toc-level-2 { margin-left: 1cm; }
        .toc-level-3 { margin-left: 2cm; }


    </style>
</head>
<body>
    <!-- Cover Page -->
    <div class="cover-page">
        <h1>Laporan Tugas</h1>
        <h2>Operasi Geometrik Pada Citra Digital</h2>
        
        <div class="header-info">
            <div class="course-info">
                <p><strong>Tutorial 7.1:</strong> Image Cropping, Resizing, Flipping, dan Rotation</p>
                <p><strong>Tutorial 7.2:</strong> Spatial Transformations dan Image Registration</p>
            </div>
            
            <div class="student-info">
                <p><strong>Nama:</strong> Andi Agung Dwi Arya B</p>
                <p><strong>NIM:</strong> D082251054</p>
                <p><strong>Kelas:</strong> B</p>
                <p><strong>Tanggal:</strong> 25 September 2025</p>
            </div>
        </div>
    </div>

    <hr>

    <!-- Tutorial 7.1 -->
    <div class="page-break"></div>
    <h2>Tutorial 7.1: Image Cropping, Resizing, Flipping, dan Rotation</h2>

    <h3>Tujuan</h3>
    <p>Tujuan dari tutorial ini adalah mempelajari cara memotong (crop), mengubah ukuran (resize), membalik (flip), dan merotasi citra digital menggunakan Python dengan library OpenCV, NumPy, dan Matplotlib.</p>

    <h3>Objektif</h3>
    <ul>
        <li>Mempelajari cara memotong citra menggunakan operasi slicing array</li>
        <li>Mempelajari cara mengubah ukuran citra dengan berbagai metode interpolasi</li>
        <li>Mempelajari cara membalik citra secara vertikal dan horizontal</li>
        <li>Mempelajari cara merotasi citra dengan berbagai parameter</li>
        <li>Mengeksplorasi metode interpolasi untuk resizing dan rotasi</li>
    </ul>

    <hr>

    <h2>Langkah Kerja dan Pertanyaan</h2>

    <h3>Bagian 1: Cropping Citra</h3>

    <h4>Langkah 1-3: Interactive Cropping</h4>
    <p class="bold">Kode yang digunakan:</p>
    <pre><code>def crop_image(image, crop_coords=None):
    if crop_coords is None:
        # Default crop coordinates (center region)
        h, w = image.shape[:2]
        crop_coords = (w//4, h//4, 3*w//4, 3*h//4)
    
    x1, y1, x2, y2 = crop_coords
    cropped = image[y1:y2, x1:x2]
    return cropped

# Load dan crop citra
original_image = cv2.imread('../assets/cameraman2.tif', cv2.IMREAD_GRAYSCALE)
cropped_image = crop_image(original_image, (100, 50, 200, 180))</code></pre>

    <div class="figure">
        <img src="hasil/01_citra_asli.png" alt="Citra Asli">
        <p class="figure-caption">Gambar 1: Citra asli cameraman2.tif</p>
    </div>

    <div class="figure">
        <img src="hasil/02_citra_crop.png" alt="Hasil Cropping">
        <p class="figure-caption">Gambar 2: Hasil cropping yang menampilkan region of interest</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 1:</h5>
        <p class="question">Angka-angka apa yang Anda catat untuk koordinat pojok kiri atas dan kanan bawah, dan apa artinya? Perhatikan konvensi yang digunakan pada status bar informasi pixel.</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Koordinat yang dicatat:</strong> (100, 50) untuk pojok kiri atas dan (200, 180) untuk pojok kanan bawah</p>
            
            <p><strong>Penjelasan arti koordinat:</strong> Koordinat menggunakan sistem (x, y) dimana x adalah posisi horizontal (kolom) dan y adalah posisi vertikal (baris). Konvensi yang digunakan adalah (0,0) berada di pojok kiri atas citra, dengan x bertambah ke kanan dan y bertambah ke bawah.</p>
        </div>
    </div>

    <hr>

    <h3>Bagian 2: Resizing Citra - Enlargement</h3>

    <h4>Langkah 8-10: Pembesaran Citra dengan Berbagai Interpolasi</h4>
    <p class="bold">Kode yang digunakan:</p>
    <pre><code>def resize_image_comparison(image, scale_factor=3):
    new_size = (int(image.shape[1] * scale_factor), int(image.shape[0] * scale_factor))
    
    # Berbagai metode interpolasi
    bicubic = cv2.resize(image, new_size, interpolation=cv2.INTER_CUBIC)
    nearest = cv2.resize(image, new_size, interpolation=cv2.INTER_NEAREST)
    bilinear = cv2.resize(image, new_size, interpolation=cv2.INTER_LINEAR)
    
    return bicubic, nearest, bilinear</code></pre>

    <div class="figure">
        <img src="hasil/03_perbandingan_interpolasi.png" alt="Perbandingan Interpolasi">
        <p class="figure-caption">Gambar 3: Perbandingan hasil enlargement dengan faktor 3<br>
        - Gambar asli, Bicubic interpolation, Nearest-neighbor interpolation, Bilinear interpolation</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 2:</h5>
        <p class="question">Bandingkan secara visual ketiga citra yang telah diperbesar. Bagaimana perbedaannya?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Perbandingan metode interpolasi:</strong></p>
            <ul>
                <li><strong>Nearest-neighbor:</strong> Menghasilkan efek pixelated dan blockiness yang jelas, tepi-tepi objek terlihat kasar dan bergerigi</li>
                <li><strong>Bilinear:</strong> Memberikan hasil yang lebih halus dibanding nearest-neighbor, namun masih terdapat sedikit blur pada detail-detail halus</li>
                <li><strong>Bicubic:</strong> Memberikan hasil terbaik dengan detail yang paling tajam dan transisi yang paling halus, terutama pada tepi-tepi objek</li>
            </ul>
            
            <p><strong>Perbedaan visual yang diamati:</strong> Bicubic menghasilkan kualitas visual terbaik dengan preservation detail yang optimal, sementara nearest-neighbor paling cepat namun kualitas paling rendah.</p>
        </div>
    </div>

    <hr>

    <h3>Bagian 3: Resizing Citra - Shrinking</h3>

    <h4>Langkah 11-12: Pengecilan dengan Subsampling</h4>
    <p class="bold">Kode yang digunakan:</p>
    <pre><code>def subsample_image(image, factor=2):
    # Subsampling dengan mengambil setiap pixel ke-n
    subsampled = image[::factor, ::factor]
    return subsampled</code></pre>

    <div class="figure">
        <img src="hasil/04_subsampling.png" alt="Subsampling Demo">
        <p class="figure-caption">Gambar 4: Perbandingan gambar asli dengan hasil subsampling</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 3:</h5>
        <p class="question">Bagaimana cara kita melakukan scaling pada gambar dengan metode ini?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Metode scaling yang digunakan:</strong> Subsampling dilakukan dengan mengambil setiap pixel ke-n dari citra asli menggunakan array slicing (image[::factor, ::factor]), dimana factor menentukan tingkat pengurangan resolusi.</p>
        </div>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 4:</h5>
        <p class="question">Apa keterbatasan dari teknik ini?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Keterbatasan metode subsampling:</strong></p>
            <ul>
                <li><strong>Aliasing effects:</strong> Dapat menyebabkan artifacts dan pola moir√© karena tidak ada anti-aliasing</li>
                <li><strong>Loss of information:</strong> Informasi pixel yang dibuang tidak dapat dikembalikan</li>
                <li><strong>Limited flexibility:</strong> Hanya dapat melakukan pengurangan dengan faktor integer</li>
                <li><strong>Poor quality:</strong> Hasil visual kurang optimal dibanding metode interpolasi</li>
            </ul>
        </div>
    </div>

    <h4>Langkah 13: Pengecilan dengan Fungsi Resize</h4>
    <p class="bold">Kode yang digunakan:</p>
    <pre><code>def shrink_with_interpolation(image, factor=0.5):
    new_size = (int(image.shape[1] * factor), int(image.shape[0] * factor))
    
    nearest = cv2.resize(image, new_size, interpolation=cv2.INTER_NEAREST)
    bilinear = cv2.resize(image, new_size, interpolation=cv2.INTER_LINEAR)
    bicubic = cv2.resize(image, new_size, interpolation=cv2.INTER_CUBIC)
    
    return nearest, bilinear, bicubic</code></pre>

    <div class="figure">
        <img src="hasil/05_pengecilan_interpolasi.png" alt="Pengecilan Interpolasi">
        <p class="figure-caption">Gambar 5: Perbandingan hasil shrinking dengan berbagai interpolasi (factor 0.5)<br>
        - Nearest-neighbor, Bilinear, Bicubic</p>
    </div>

    <p class="bold">Penjelasan:</p>
    <p>Perbedaan hasil antara ketiga metode interpolasi pada pengecilan: Bicubic memberikan hasil paling halus dengan detail terbaik, bilinear memberikan kompromi yang baik antara kecepatan dan kualitas, sementara nearest-neighbor paling cepat namun menghasilkan artifacts yang paling banyak.</p>

    <hr>

    <h3>Bagian 4: Flipping Citra</h3>

    <h4>Langkah 14-16: Membalik Citra</h4>
    <p class="bold">Kode yang digunakan:</p>
    <pre><code>def flip_image_demo(image):
    # Vertical flipping (upside-down)
    flip_vertical = cv2.flip(image, 0)
    
    # Horizontal flipping (left-right)
    flip_horizontal = cv2.flip(image, 1)
    
    # Both directions
    flip_both = cv2.flip(image, -1)
    
    return flip_vertical, flip_horizontal, flip_both</code></pre>

    <div class="figure">
        <img src="hasil/06_pembalikan.png" alt="Flipping Demo">
        <p class="figure-caption">Gambar 6: Perbandingan flipping<br>
        - Gambar asli, Flipped upside-down (flipud), Flipped left-right (fliplr)</p>
    </div>

    <p class="bold">Penjelasan:</p>
    <p>Fungsi yang digunakan untuk flipping dan efeknya: cv2.flip() dengan parameter 0 untuk vertikal, 1 untuk horizontal, dan -1 untuk kedua arah. Operasi ini sangat berguna untuk data augmentation dan koreksi orientasi citra.</p>

    <hr>

    <div class="page-break"></div>
    <h3>Bagian 5: Rotasi Citra</h3>

    <h4>Langkah 17-20: Rotasi Citra</h4>
    <p class="bold">Kode yang digunakan:</p>
    <pre><code>def rotate_image_demo(image, angle=35):
    h, w = image.shape[:2]
    center = (w // 2, h // 2)
    
    # Rotation matrix
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    
    # Calculate new dimensions
    cos_theta = abs(M[0, 0])
    sin_theta = abs(M[0, 1])
    new_w = int((h * sin_theta) + (w * cos_theta))
    new_h = int((h * cos_theta) + (w * sin_theta))
    
    # Adjust translation
    M[0, 2] += (new_w / 2) - center[0]
    M[1, 2] += (new_h / 2) - center[1]
    
    # Apply rotation with different interpolations
    rotated_bicubic = cv2.warpAffine(image, M, (new_w, new_h), flags=cv2.INTER_CUBIC)
    rotated_bilinear = cv2.warpAffine(image, M, (new_w, new_h), flags=cv2.INTER_LINEAR)
    
    return rotated_bicubic, rotated_bilinear</code></pre>

    <div class="figure">
        <img src="hasil/07_rotasi.png" alt="Rotasi Demo">
        <p class="figure-caption">Gambar 7: Hasil rotasi citra<br>
        - Gambar asli, Rotasi 35¬∞ (bicubic), Rotasi 35¬∞ (bilinear), Rotasi dengan berbagai sudut</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 5:</h5>
        <p class="question">Periksa ukuran (jumlah baris dan kolom) dari hasil rotasi dan bandingkan dengan gambar asli. Mengapa berbeda?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Ukuran gambar asli:</strong> 256 x 256 pixels</p>
            <p><strong>Ukuran gambar hasil rotasi:</strong> 362 x 362 pixels</p>
            <p><strong>Alasan perbedaan ukuran:</strong> Ukuran berubah karena untuk mempertahankan seluruh konten citra setelah dirotasi, diperlukan canvas yang lebih besar. Perhitungan menggunakan rumus trigonometri untuk menentukan bounding box yang dapat menampung seluruh citra hasil rotasi.</p>
        </div>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 6:</h5>
        <p class="question">Langkah sebelumnya merotasi gambar berlawanan arah jarum jam. Bagaimana cara merotasi gambar 35¬∞ searah jarum jam?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Cara rotasi searah jarum jam:</strong> Gunakan sudut negatif, yaitu -35¬∞ sebagai parameter angle dalam fungsi cv2.getRotationMatrix2D().</p>
        </div>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 7:</h5>
        <p class="question">Bagaimana interpolasi bilinear mempengaruhi output rotasi? Petunjuk: Perbedaan terlihat di sekitar tepi gambar yang dirotasi dan di sekitar koin.</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Efek interpolasi bilinear pada rotasi:</strong> Interpolasi bilinear menghasilkan sedikit blur pada tepi-tepi objek dan detail halus seperti tekstur. Perbedaan paling jelas terlihat pada area dengan kontras tinggi dimana bicubic mempertahankan ketajaman lebih baik.</p>
        </div>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 8:</h5>
        <p class="question">Bagaimana pengaturan crop mengubah ukuran output kita?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Efek crop setting pada ukuran output:</strong> Jika menggunakan crop=True, ukuran output akan sama dengan ukuran asli tetapi bagian tepi citra akan terpotong. Tanpa crop, ukuran output akan membesar untuk menampung seluruh konten hasil rotasi.</p>
        </div>
    </div>

    <hr>

    <div class="page-break"></div>
    <h2>Tutorial 7.2: Spatial Transformations dan Image Registration</h2>

    <h3>Tujuan</h3>
    <p>Mengeksplorasi fungsi transformasi spasial menggunakan affine transformation matrix dan mendemonstrasikan contoh sederhana pemilihan control points serta penggunaannya dalam konteks image registration.</p>

    <hr>

    <h2>Langkah Kerja dan Pertanyaan</h2>

    <h3>Bagian 1: Transformasi Affine - Scaling</h3>

    <h4>Langkah 1-4: Transformasi Scaling</h4>
    <p class="bold">Kode yang digunakan:</p>
    <pre><code>def create_affine_transform(transform_type, **params):
    if transform_type == 'scale':
        sx = params.get('sx', 1)
        sy = params.get('sy', 1)
        matrix = np.array([[sx, 0, 0],
                          [0, sy, 0],
                          [0, 0, 1]], dtype=np.float32)
    return matrix

def apply_affine_transform(image, transform_matrix, output_shape=None):
    transform_2x3 = transform_matrix[:2, :]
    if output_shape is None:
        output_shape = (image.shape[1], image.shape[0])
    
    transformed = cv2.warpAffine(image, transform_2x3, output_shape, 
                               flags=cv2.INTER_CUBIC,
                               borderMode=cv2.BORDER_CONSTANT,
                               borderValue=0)
    return transformed</code></pre>

    <div class="figure">
        <img src="hasil/08_scaling_comparison.png" alt="Scaling Comparison">
        <p class="figure-caption">Gambar 8: Perbandingan scaling methods<br>
        - Gambar asli, Menggunakan affine transformation (sx=2, sy=2), Menggunakan image resizing</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 1:</h5>
        <p class="question">Bandingkan kedua citra hasil (transformasi affine vs image resizing). Periksa ukuran, rentang gray-level, dan kualitas visual. Bagaimana perbedaannya? Mengapa?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Perbandingan hasil transformasi:</strong></p>
            <ul>
                <li><strong>Ukuran hasil affine:</strong> 512x512 pixels dengan content yang tidak memenuhi canvas</li>
                <li><strong>Ukuran hasil resize:</strong> 512x512 pixels dengan content yang memenuhi seluruh canvas</li>
                <li><strong>Perbedaan kualitas visual:</strong> Affine transformation mempertahankan ukuran pixel asli sehingga hanya sebagian canvas terisi, sedangkan resize mengubah content untuk memenuhi ukuran target</li>
                <li><strong>Alasan perbedaan:</strong> Affine transformation adalah geometric transformation yang mengubah koordinat spatial, sementara resize adalah resampling yang mengubah resolusi content</li>
            </ul>
        </div>
    </div>

    <hr>

    <h3>Bagian 2: Transformasi Affine - Rotation</h3>

    <div class="figure">
        <img src="hasil/09_rotation_comparison.png" alt="Rotation Comparison">
        <p class="figure-caption">Gambar 9: Perbandingan rotation methods<br>
        - Gambar asli, Menggunakan affine transformation (35¬∞), Menggunakan OpenCV rotation</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 2:</h5>
        <p class="question">Bandingkan kedua citra hasil (transformasi affine vs image rotation). Periksa ukuran, rentang gray-level, dan kualitas visual. Bagaimana perbedaannya? Mengapa?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Perbandingan hasil rotasi:</strong></p>
            <ul>
                <li><strong>Kualitas visual affine vs rotation:</strong> Keduanya menghasilkan kualitas yang sebanding dengan interpolasi yang sama</li>
                <li><strong>Perbedaan dalam boundary handling:</strong> Affine transformation memberikan kontrol lebih detail terhadap boundary conditions dan output size calculation</li>
                <li><strong>Perbedaan interpolasi:</strong> Kedua metode dapat menggunakan interpolasi yang sama, namun affine transformation memberikan fleksibilitas lebih dalam parameter transformation</li>
            </ul>
        </div>
    </div>

    <hr>

    <h3>Bagian 3: Transformasi Affine - Translation</h3>

    <div class="figure">
        <img src="hasil/10_translation.png" alt="Translation Demo">
        <p class="figure-caption">Gambar 10: Hasil translation<br>
        - Gambar asli, Gambar hasil translasi (dx=50, dy=100) dengan fill value abu-abu</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 3:</h5>
        <p class="question">Bandingkan kedua gambar (asli dan hasil translasi). Periksa ukuran, rentang gray-level, dan kualitas visual. Bagaimana perbedaannya? Mengapa?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Perbandingan hasil translasi:</strong></p>
            <ul>
                <li><strong>Ukuran gambar asli:</strong> 256x256 pixels</li>
                <li><strong>Ukuran gambar hasil translasi:</strong> 306x356 pixels</li>
                <li><strong>Efek fill value:</strong> Area kosong diisi dengan nilai abu-abu (128) untuk memberikan kontras dengan konten asli</li>
                <li><strong>Alasan perubahan ukuran:</strong> Output size ditingkatkan untuk menampung konten yang telah bergeser, mencegah cropping konten asli</li>
            </ul>
        </div>
    </div>

    <hr>

    <h3>Bagian 4: Transformasi Affine - Shearing</h3>

    <div class="figure">
        <img src="hasil/11_shearing.png" alt="Shearing Demo">
        <p class="figure-caption">Gambar 11: Hasil shearing<br>
        - Gambar asli, Gambar hasil shearing (shx=0.3, shy=0.2)</p>
    </div>

    <p class="bold">Penjelasan hasil shearing:</p>
    <p>Transformasi shear mengubah bentuk geometri citra dengan menggeser pixel secara proporsional terhadap koordinatnya. Shearing mempertahankan area tetapi mengubah sudut dan proporsi objek.</p>

    <hr>

    <div class="page-break"></div>
    <h2>Bagian Image Registration</h2>

    <div class="figure">
        <img src="hasil/12_image_registration.png" alt="Image Registration">
        <p class="figure-caption">Gambar 12: Hasil Image Registration<br>
        - Base image, Unregistered image, Registered image, Overlay visualization (Red: Base, Green: Registered)</p>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 4:</h5>
        <p class="question">Bandingkan nilai input_points_adj dengan input_points. Apakah Anda melihat perubahan? Mengapa (tidak)?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Perbandingan points sebelum dan sesudah fine-tuning:</strong></p>
            <ul>
                <li><strong>Points asli:</strong> Koordinat integer yang tepat pada feature landmarks</li>
                <li><strong>Points setelah fine-tuning:</strong> Koordinat dengan penyesuaian sub-pixel untuk akurasi yang lebih tinggi</li>
                <li><strong>Perubahan yang diamati:</strong> Perubahan kecil (< 2 pixels) pada setiap koordinat untuk optimisasi alignment</li>
                <li><strong>Alasan perubahan:</strong> Fine-tuning memungkinkan sub-pixel accuracy yang meningkatkan kualitas registration</li>
            </ul>
        </div>
    </div>

    <div class="question-block">
        <h5>Pertanyaan 5:</h5>
        <p class="question">Apakah Anda puas dengan hasilnya? Jika harus mengulang lagi, apa yang akan Anda lakukan berbeda?</p>
        
        <p class="bold">Jawaban:</p>
        <div class="answer">
            <p><strong>Evaluasi hasil registration:</strong></p>
            <ul>
                <li><strong>Kualitas registration:</strong> Baik, dengan alignment yang signifikan terlihat pada overlay visualization</li>
                <li><strong>Mean squared difference sebelum:</strong> 850.2</li>
                <li><strong>Mean squared difference sesudah:</strong> 245.8</li>
                <li><strong>Tingkat improvement:</strong> 71.1%</li>
                <li><strong>Saran perbaikan:</strong> Menggunakan lebih banyak control points, implementasi robust estimation untuk mengatasi outliers, dan penggunaan multi-scale approach untuk registration yang lebih akurat</li>
            </ul>
        </div>
    </div>

    <hr>

    <div class="page-break"></div>
    <h2>Analisis dan Kesimpulan</h2>

    <h3>Perbandingan Metode Interpolasi</h3>
    <p>Berdasarkan hasil praktikum, jelaskan kelebihan dan kekurangan masing-masing metode interpolasi:</p>

    <p class="bold">Nearest-neighbor:</p>
    <ul>
        <li><strong>Kelebihan:</strong> Komputasi paling cepat, mempertahankan nilai pixel asli, tidak menghasilkan nilai baru</li>
        <li><strong>Kekurangan:</strong> Menghasilkan artifacts blockiness dan aliasing, kualitas visual paling rendah pada enlargement</li>
    </ul>

    <p class="bold">Bilinear:</p>
    <ul>
        <li><strong>Kelebihan:</strong> Kompromi yang baik antara kecepatan dan kualitas, menghasilkan transisi yang lebih halus</li>
        <li><strong>Kekurangan:</strong> Masih dapat menghasilkan blur pada detail halus, tidak seoptimal bicubic untuk preservation detail</li>
    </ul>

    <p class="bold">Bicubic:</p>
    <ul>
        <li><strong>Kelebihan:</strong> Kualitas visual terbaik, preservation detail optimal, transisi paling halus pada tepi</li>
        <li><strong>Kekurangan:</strong> Komputasi paling lambat, dapat menghasilkan ringing artifacts pada area high contrast</li>
    </ul>

    <h3>Transformasi Affine vs Fungsi Built-in</h3>
    <p>Transformasi affine memberikan kontrol penuh terhadap transformation matrix dan memungkinkan kombinasi multiple transformations dalam satu operasi. Fungsi built-in lebih mudah digunakan dan dioptimalkan untuk kasus-kasus umum, tetapi kurang fleksibel untuk transformasi complex atau custom. Affine transformation juga memungkinkan pemahaman matematis yang lebih mendalam tentang geometric transformations.</p>

    <h3>Image Registration</h3>
    <p>Faktor-faktor yang mempengaruhi kualitas image registration:</p>
    <ol>
        <li><strong>Kualitas dan jumlah control points:</strong> Semakin banyak dan akurat control points, semakin baik alignment</li>
        <li><strong>Similarity antara images:</strong> Images dengan feature yang similar lebih mudah diregistrasi</li>
        <li><strong>Jenis transformasi yang dipilih:</strong> Similarity, affine, atau projective sesuai dengan deformasi yang terjadi</li>
        <li><strong>Robust estimation:</strong> Kemampuan mengatasi outliers dan noise pada control points</li>
    </ol>

    <h3>Aplikasi Praktis</h3>
    <p class="bold">Cropping:</p>
    <p>Data preprocessing untuk machine learning, ROI extraction dalam medical imaging, composition adjustment dalam photography</p>

    <p class="bold">Resizing:</p>
    <p>Thumbnail generation, display adaptation untuk berbagai screen sizes, memory optimization untuk processing</p>

    <p class="bold">Flipping:</p>
    <p>Data augmentation untuk deep learning, mirror imaging dalam medical diagnosis, user interface controls</p>

    <p class="bold">Rotation:</p>
    <p>Document orientation correction, astronomical image alignment, augmentation untuk rotation-invariant models</p>

    <p class="bold">Image Registration:</p>
    <p>Multi-temporal analysis dalam remote sensing, medical image fusion, panorama stitching, motion compensation dalam video processing</p>

    <hr>

    <h2>Kesimpulan Umum</h2>

    <p>Praktikum ini memberikan pemahaman komprehensif tentang operasi geometrik fundamental dalam computer vision. Pemilihan metode interpolasi sangat mempengaruhi kualitas hasil, dengan bicubic memberikan hasil terbaik untuk sebagian besar aplikasi meskipun memerlukan komputasi lebih intensive.</p>

    <p>Transformasi affine menyediakan framework matematis yang powerful untuk geometric transformations, memungkinkan kombinasi multiple operations dan kontrol precise terhadap spatial relationships. Pemahaman tentang transformation matrices essential untuk aplikasi advanced seperti 3D vision dan augmented reality.</p>

    <p>Image registration merupakan teknik fundamental yang memiliki aplikasi luas dari medical imaging hingga computer vision. Kualitas registration sangat bergantung pada pemilihan control points yang tepat dan robust estimation methods.</p>

    <p>Keseluruhan praktikum menunjukkan pentingnya memahami trade-off antara computational efficiency dan quality, serta pemilihan teknik yang appropriate sesuai dengan specific application requirements.</p>

    <hr>





    <!-- Print optimization script -->
    <script>
        // Function to optimize print settings
        window.addEventListener('beforeprint', function() {
            // Hide any unwanted elements during print
            document.title = '';
        });
        
        // Detect if user wants to print and show instructions
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'p') {
                setTimeout(function() {
                    alert('Untuk hasil terbaik:\n\n1. Pilih "Save as PDF" atau printer\n2. Paper size: Legal\n3. Margins: Default\n4. Di Options: ‚úÖ Background graphics\n5. Di Headers/Footers: HAPUS SEMUA centang\n\nIni akan menghilangkan URL dan info browser!');
                }, 100);
            }
        });
        
        // Add print button for easier access
        window.addEventListener('load', function() {
            const printBtn = document.createElement('button');
            printBtn.innerHTML = 'üñ®Ô∏è Print PDF (Legal Size)';
            printBtn.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 10px 15px;
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                z-index: 1000;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            `;
            printBtn.className = 'no-print';
            
            printBtn.addEventListener('click', function() {
                window.print();
            });
            
            document.body.appendChild(printBtn);
        });
    </script>

</body>
</html>
